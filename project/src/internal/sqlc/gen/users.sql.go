// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package gen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (uuid, name, email, password, role_id, updated_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type CreateUserParams struct {
	Uuid      uuid.UUID
	Name      string
	Email     string
	Password  string
	RoleID    int32
	UpdatedAt pgtype.Timestamp
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int32, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Uuid,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.RoleID,
		arg.UpdatedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const findRoleByID = `-- name: FindRoleByID :one
SELECT id, role, description, created_at, updated_at, deleted_at
FROM roles r
WHERE r.id = $1
`

func (q *Queries) FindRoleByID(ctx context.Context, id int32) (Role, error) {
	row := q.db.QueryRow(ctx, findRoleByID, id)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Role,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT u.id,
   u.uuid,
   u.name,
   u.email,
   r.role,
   u.role_id,
   u.enabled,
   u.password,
   u.created_at,
   u.updated_at
FROM users u
   LEFT JOIN roles r ON u.role_id = r.id
WHERE u.email = $1
   AND u.deleted_at IS NULL
LIMIT 1
`

type FindUserByEmailRow struct {
	ID        int32
	Uuid      uuid.UUID
	Name      string
	Email     string
	Role      NullPositionType
	RoleID    int32
	Enabled   bool
	Password  string
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (FindUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, findUserByEmail, email)
	var i FindUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.RoleID,
		&i.Enabled,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findUserByID = `-- name: FindUserByID :one
SELECT u.id,
   u.uuid,
   u.name,
   u.email,
   r.role,
   u.enabled,
   u.password,
   u.created_at,
   u.updated_at
FROM users u
   LEFT JOIN roles r ON u.role_id = r.id
WHERE u.id = $1
   AND u.deleted_at IS NULL
LIMIT 1
`

type FindUserByIDRow struct {
	ID        int32
	Uuid      uuid.UUID
	Name      string
	Email     string
	Role      NullPositionType
	Enabled   bool
	Password  string
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

func (q *Queries) FindUserByID(ctx context.Context, id int32) (FindUserByIDRow, error) {
	row := q.db.QueryRow(ctx, findUserByID, id)
	var i FindUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Enabled,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTotalUsers = `-- name: GetTotalUsers :one
SELECT COUNT(*)
FROM users u
WHERE u.deleted_at IS NULL
`

func (q *Queries) GetTotalUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUsersWithTotal = `-- name: GetUsersWithTotal :many
WITH users_page AS (
   SELECT u.id,
      u.uuid,
      u.name,
      u.email,
      r.role,
      u.enabled,
      u.created_at,
      u.updated_at
   FROM users u
      LEFT JOIN roles r ON u.role_id = r.id
   WHERE u.deleted_at IS NULL
   ORDER BY u.id DESC
   LIMIT $1 OFFSET $2
),
total AS (
   SELECT COUNT(*) AS total_count
   FROM users u
   WHERE u.deleted_at IS NULL
)
SELECT up.id,
   up.uuid,
   up.name,
   up.email,
   up.role,
   up.enabled,
   up.created_at,
   up.updated_at,
   t.total_count
FROM users_page up
   CROSS JOIN total t
`

type GetUsersWithTotalParams struct {
	Limit  int
	Offset int
}

type GetUsersWithTotalRow struct {
	ID         int32
	Uuid       uuid.UUID
	Name       string
	Email      string
	Role       NullPositionType
	Enabled    bool
	CreatedAt  pgtype.Timestamp
	UpdatedAt  pgtype.Timestamp
	TotalCount int64
}

func (q *Queries) GetUsersWithTotal(ctx context.Context, arg GetUsersWithTotalParams) ([]GetUsersWithTotalRow, error) {
	rows, err := q.db.Query(ctx, getUsersWithTotal, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersWithTotalRow
	for rows.Next() {
		var i GetUsersWithTotalRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Name,
			&i.Email,
			&i.Role,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsers = `-- name: SearchUsers :many
WITH users_page AS (
   SELECT u.id,
      u.uuid,
      u.name,
      u.email,
      r.role,
      u.enabled,
      u.created_at,
      u.updated_at
   FROM users u
      LEFT JOIN roles r ON u.role_id = r.id
   WHERE u.deleted_at IS NULL
      AND (
         LOWER(u.name) LIKE '%' || $1 || '%'
         OR LOWER(u.email) LIKE '%' || $2 || '%'
      )
   ORDER BY u.id DESC
   LIMIT $3 OFFSET $4
),
total AS (
   SELECT COUNT(*) AS total_count
   FROM users u
   WHERE u.deleted_at IS NULL
      AND (
         LOWER(u.name) LIKE '%' || $5 || '%'
         OR LOWER(u.email) LIKE '%' || $6 || '%'
      )
)
SELECT up.id,
   up.uuid,
   up.name,
   up.email,
   up.role,
   up.enabled,
   up.created_at,
   up.updated_at,
   t.total_count
FROM users_page up
   CROSS JOIN total t
`

type SearchUsersParams struct {
	Column1 pgtype.Text
	Column2 pgtype.Text
	Limit   int
	Offset  int
	Column5 pgtype.Text
	Column6 pgtype.Text
}

type SearchUsersRow struct {
	ID         int32
	Uuid       uuid.UUID
	Name       string
	Email      string
	Role       NullPositionType
	Enabled    bool
	CreatedAt  pgtype.Timestamp
	UpdatedAt  pgtype.Timestamp
	TotalCount int64
}

func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]SearchUsersRow, error) {
	rows, err := q.db.Query(ctx, searchUsers,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
		arg.Column5,
		arg.Column6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchUsersRow
	for rows.Next() {
		var i SearchUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Name,
			&i.Email,
			&i.Role,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET name = COALESCE($1, name),
   email = COALESCE($2, email),
   password = COALESCE($3, password),
   updated_at = $4
WHERE id = $5
`

type UpdateUserParams struct {
	Name      pgtype.Text
	Email     pgtype.Text
	Password  pgtype.Text
	UpdatedAt pgtype.Timestamp
	ID        int32
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateUserAdmin = `-- name: UpdateUserAdmin :exec
UPDATE users
SET name = COALESCE($1, name),
   email = COALESCE($2, email),
   password = COALESCE($3, password),
   updated_at = $4,
   role_id = COALESCE($5, role_id),
   deleted_at = COALESCE($6, deleted_at),
   enabled = COALESCE($7, enabled)
WHERE id = $8
`

type UpdateUserAdminParams struct {
	Name      pgtype.Text
	Email     pgtype.Text
	Password  pgtype.Text
	UpdatedAt pgtype.Timestamp
	RoleID    pgtype.Int4
	DeletedAt pgtype.Timestamp
	Enabled   pgtype.Bool
	ID        int32
}

func (q *Queries) UpdateUserAdmin(ctx context.Context, arg UpdateUserAdminParams) error {
	_, err := q.db.Exec(ctx, updateUserAdmin,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.UpdatedAt,
		arg.RoleID,
		arg.DeletedAt,
		arg.Enabled,
		arg.ID,
	)
	return err
}
