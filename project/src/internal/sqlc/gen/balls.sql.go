// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: balls.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getBallsWithTotal = `-- name: GetBallsWithTotal :many
SELECT
    id,
    amount as total
FROM balls
WHERE id = ANY($1::int[])
`

type GetBallsWithTotalRow struct {
	ID    int32
	Total pgtype.Int4
}

func (q *Queries) GetBallsWithTotal(ctx context.Context, ids []int32) ([]GetBallsWithTotalRow, error) {
	rows, err := q.db.Query(ctx, getBallsWithTotal, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBallsWithTotalRow
	for rows.Next() {
		var i GetBallsWithTotalRow
		if err := rows.Scan(&i.ID, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementBallAmount = `-- name: IncrementBallAmount :exec
UPDATE balls
SET amount = amount + 1,
    last_draw_id = $1,
    last_draw_at = $2
WHERE id = CAST($3 AS INTEGER)
`

type IncrementBallAmountParams struct {
	DrawID   pgtype.Int4
	DrawDate pgtype.Date
	Ball     int32
}

func (q *Queries) IncrementBallAmount(ctx context.Context, arg IncrementBallAmountParams) error {
	_, err := q.db.Exec(ctx, incrementBallAmount, arg.DrawID, arg.DrawDate, arg.Ball)
	return err
}

const incrementBallsAmountBatch = `-- name: IncrementBallsAmountBatch :exec
UPDATE balls b
SET amount = v.ball_amount,
    last_draw_id = v.draw_id,
    last_draw_at = v.draw_date
FROM (
        SELECT UNNEST($1::int []) AS ball_id,
            UNNEST($2::int []) AS draw_id,
            UNNEST($3::date []) AS draw_date,
            UNNEST($4::int []) AS ball_amount
    ) v
WHERE b.id = v.ball_id
`

type IncrementBallsAmountBatchParams struct {
	BallIds   []int32
	DrawIds   []int32
	DrawDates []pgtype.Date
	Amount    []int32
}

func (q *Queries) IncrementBallsAmountBatch(ctx context.Context, arg IncrementBallsAmountBatchParams) error {
	_, err := q.db.Exec(ctx, incrementBallsAmountBatch,
		arg.BallIds,
		arg.DrawIds,
		arg.DrawDates,
		arg.Amount,
	)
	return err
}

const listBallsAsc = `-- name: ListBallsAsc :many
SELECT id, amount, last_draw_id, last_draw_at, section
FROM balls
ORDER BY id ASC
`

func (q *Queries) ListBallsAsc(ctx context.Context) ([]Ball, error) {
	rows, err := q.db.Query(ctx, listBallsAsc)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ball
	for rows.Next() {
		var i Ball
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.LastDrawID,
			&i.LastDrawAt,
			&i.Section,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBallSectionsBatch = `-- name: UpdateBallSectionsBatch :exec
UPDATE balls b
SET section = data.section
FROM (
    SELECT
        unnest($1::int[]) AS id,
        unnest($2::balls_sections[]) AS section
) AS data
WHERE b.id = data.id
`

type UpdateBallSectionsBatchParams struct {
	Ids      []int32
	Sections []string
}

func (q *Queries) UpdateBallSectionsBatch(ctx context.Context, arg UpdateBallSectionsBatchParams) error {
	_, err := q.db.Exec(ctx, updateBallSectionsBatch, arg.Ids, arg.Sections)
	return err
}
