// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: draws.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countDraws = `-- name: CountDraws :one
SELECT COUNT(*)
FROM draws
`

func (q *Queries) CountDraws(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDraws)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteDrawBalls = `-- name: DeleteDrawBalls :exec
DELETE FROM draw_balls
WHERE draw_id = $1
`

func (q *Queries) DeleteDrawBalls(ctx context.Context, drawID int32) error {
	_, err := q.db.Exec(ctx, deleteDrawBalls, drawID)
	return err
}

const deletePatternBallsBatch = `-- name: DeletePatternBallsBatch :exec
WITH pairs AS (
    SELECT UNNEST($1::int []) AS pattern_id,
        UNNEST($2::int []) AS ball_id
),
updated AS (
    UPDATE pattern_balls pb
    SET amount = amount - 1
    FROM pairs p
    WHERE pb.pattern_id = p.pattern_id
        AND pb.ball_id = p.ball_id
        AND pb.amount > 1
)
DELETE FROM pattern_balls pb USING pairs p
WHERE pb.pattern_id = p.pattern_id
    AND pb.ball_id = p.ball_id
    AND pb.amount = 1
`

type DeletePatternBallsBatchParams struct {
	PatternIds []int32
	BallsIds   []int32
}

func (q *Queries) DeletePatternBallsBatch(ctx context.Context, arg DeletePatternBallsBatchParams) error {
	_, err := q.db.Exec(ctx, deletePatternBallsBatch, arg.PatternIds, arg.BallsIds)
	return err
}

const getDrawBalls = `-- name: GetDrawBalls :many
SELECT ball_id
FROM draw_balls
WHERE draw_id = $1
`

// =========================
// DRAW BALLS MAINTENANCE
// =========================
func (q *Queries) GetDrawBalls(ctx context.Context, drawID int32) ([]int32, error) {
	rows, err := q.db.Query(ctx, getDrawBalls, drawID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var ball_id int32
		if err := rows.Scan(&ball_id); err != nil {
			return nil, err
		}
		items = append(items, ball_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDrawByContestID = `-- name: GetDrawByContestID :one
SELECT id, b1, b2, b3, b4, b5, b6, pattern_id, draw_date, amount, balls_freq, draw_sections, editable
FROM draws
WHERE id = $1
`

func (q *Queries) GetDrawByContestID(ctx context.Context, id int32) (Draw, error) {
	row := q.db.QueryRow(ctx, getDrawByContestID, id)
	var i Draw
	err := row.Scan(
		&i.ID,
		&i.B1,
		&i.B2,
		&i.B3,
		&i.B4,
		&i.B5,
		&i.B6,
		&i.PatternID,
		&i.DrawDate,
		&i.Amount,
		&i.BallsFreq,
		&i.DrawSections,
		&i.Editable,
	)
	return i, err
}

const getDrawsContainingBallsWithPatterns = `-- name: GetDrawsContainingBallsWithPatterns :many
SELECT draw_id, draw_date, pattern_id, b1, b2, b3, b4, b5, b6, sum,
    COUNT(*) OVER() AS total_count
FROM (
        SELECT d.id AS draw_id,
            d.draw_date,
            p.id AS pattern_id,
            d.b1,
            d.b2,
            d.b3,
            d.b4,
            d.b5,
            d.b6,
            d.amount AS sum
        FROM draws d
            JOIN draw_balls db ON db.draw_id = d.id
            LEFT JOIN draw_patterns dp ON dp.draw_id = d.id
            LEFT JOIN patterns p ON p.id = dp.pattern_id
        WHERE db.ball_id = ANY($4)
        GROUP BY d.id,
            d.draw_date,
            p.id,
            d.b1,
            d.b2,
            d.b3,
            d.b4,
            d.b5,
            d.b6,
            d.amount
        HAVING COUNT(DISTINCT db.ball_id) = $1
        ORDER BY d.id DESC
    ) t
LIMIT $2 OFFSET $3
`

type GetDrawsContainingBallsWithPatternsParams struct {
	BallID  int32
	Limit   int
	Offset  int
	BallIds []int32
}

type GetDrawsContainingBallsWithPatternsRow struct {
	DrawID     int32
	DrawDate   pgtype.Date
	PatternID  pgtype.Int4
	B1         int32
	B2         int32
	B3         int32
	B4         int32
	B5         int32
	B6         int32
	Sum        pgtype.Int4
	TotalCount int64
}

// =========================
// COMPLEX QUERIES
// =========================
func (q *Queries) GetDrawsContainingBallsWithPatterns(ctx context.Context, arg GetDrawsContainingBallsWithPatternsParams) ([]GetDrawsContainingBallsWithPatternsRow, error) {
	rows, err := q.db.Query(ctx, getDrawsContainingBallsWithPatterns,
		arg.BallID,
		arg.Limit,
		arg.Offset,
		arg.BallIds,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDrawsContainingBallsWithPatternsRow
	for rows.Next() {
		var i GetDrawsContainingBallsWithPatternsRow
		if err := rows.Scan(
			&i.DrawID,
			&i.DrawDate,
			&i.PatternID,
			&i.B1,
			&i.B2,
			&i.B3,
			&i.B4,
			&i.B5,
			&i.B6,
			&i.Sum,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDrawsTotal = `-- name: GetDrawsTotal :one
SELECT COUNT(*)::int4 AS total
FROM draws
`

func (q *Queries) GetDrawsTotal(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, getDrawsTotal)
	var total int32
	err := row.Scan(&total)
	return total, err
}

const getTotalDrawsFromPatternID = `-- name: GetTotalDrawsFromPatternID :one
SELECT COUNT(*)::int4 AS total
FROM draws
WHERE pattern_id = $1
`

func (q *Queries) GetTotalDrawsFromPatternID(ctx context.Context, patternID int32) (int32, error) {
	row := q.db.QueryRow(ctx, getTotalDrawsFromPatternID, patternID)
	var total int32
	err := row.Scan(&total)
	return total, err
}

const insertDrawBallBatch = `-- name: InsertDrawBallBatch :exec
INSERT INTO draw_balls (draw_id, ball_id)
select UNNEST($1::int []),
    UNNEST($2::int []) on CONFLICT (draw_id, ball_id) do nothing
`

type InsertDrawBallBatchParams struct {
	DrawIds []int32
	BallIds []int32
}

// =========================
// DRAW â†” BALLS / PATTERNS
// =========================
func (q *Queries) InsertDrawBallBatch(ctx context.Context, arg InsertDrawBallBatchParams) error {
	_, err := q.db.Exec(ctx, insertDrawBallBatch, arg.DrawIds, arg.BallIds)
	return err
}

const insertDrawPattern = `-- name: InsertDrawPattern :exec
INSERT INTO draw_patterns (draw_id, pattern_id)
VALUES ($1, $2)
`

type InsertDrawPatternParams struct {
	DrawID    int32
	PatternID int32
}

func (q *Queries) InsertDrawPattern(ctx context.Context, arg InsertDrawPatternParams) error {
	_, err := q.db.Exec(ctx, insertDrawPattern, arg.DrawID, arg.PatternID)
	return err
}

const insertDrawPatternBatch = `-- name: InsertDrawPatternBatch :exec
INSERT INTO draw_patterns (draw_id, pattern_id)
SELECT UNNEST($1::int []),
    UNNEST($2::int []) ON CONFLICT (draw_id, pattern_id) DO NOTHING
`

type InsertDrawPatternBatchParams struct {
	DrawIds    []int32
	PatternIds []int32
}

func (q *Queries) InsertDrawPatternBatch(ctx context.Context, arg InsertDrawPatternBatchParams) error {
	_, err := q.db.Exec(ctx, insertDrawPatternBatch, arg.DrawIds, arg.PatternIds)
	return err
}

const insertPatternBallsBatch = `-- name: InsertPatternBallsBatch :exec
WITH pairs AS (
    SELECT UNNEST($1::int []) AS pattern_id,
        UNNEST($2::int []) AS ball_id
),
grouped AS (
    SELECT pattern_id,
        ball_id,
        COUNT(*) AS cnt
    FROM pairs
    GROUP BY pattern_id,
        ball_id
)
INSERT INTO pattern_balls (pattern_id, ball_id, amount)
SELECT pattern_id,
    ball_id,
    cnt
FROM grouped ON CONFLICT (pattern_id, ball_id) DO
UPDATE
SET amount = pattern_balls.amount + EXCLUDED.amount
`

type InsertPatternBallsBatchParams struct {
	PatternIds []int32
	BallsIds   []int32
}

func (q *Queries) InsertPatternBallsBatch(ctx context.Context, arg InsertPatternBallsBatchParams) error {
	_, err := q.db.Exec(ctx, insertPatternBallsBatch, arg.PatternIds, arg.BallsIds)
	return err
}

const insertPatternBallsSingle = `-- name: InsertPatternBallsSingle :exec
INSERT INTO pattern_balls (pattern_id, ball_id)
SELECT UNNEST($1::int []),
    UNNEST($2::int []) ON CONFLICT (pattern_id, ball_id) DO
UPDATE
SET amount = pattern_balls.amount + 1
`

type InsertPatternBallsSingleParams struct {
	PatternIds []int32
	BallsIds   []int32
}

func (q *Queries) InsertPatternBallsSingle(ctx context.Context, arg InsertPatternBallsSingleParams) error {
	_, err := q.db.Exec(ctx, insertPatternBallsSingle, arg.PatternIds, arg.BallsIds)
	return err
}

const listDrawsByDate = `-- name: ListDrawsByDate :many
SELECT d.id,
    d.b1,
    d.b2,
    d.b3,
    d.b4,
    d.b5,
    d.b6,
    d.pattern_id,
    d.draw_date,
    d.amount,
    d.draw_sections
FROM draws d
ORDER BY CASE
        WHEN $1 = 'desc' THEN d.draw_date
    END DESC,
    CASE
        WHEN $1 = 'asc' THEN d.draw_date
    END ASC
LIMIT $2 OFFSET $3
`

type ListDrawsByDateParams struct {
	Column1 interface{}
	Limit   int
	Offset  int
}

type ListDrawsByDateRow struct {
	ID           int32
	B1           int32
	B2           int32
	B3           int32
	B4           int32
	B5           int32
	B6           int32
	PatternID    int32
	DrawDate     pgtype.Date
	Amount       pgtype.Int4
	DrawSections pgtype.Text
}

func (q *Queries) ListDrawsByDate(ctx context.Context, arg ListDrawsByDateParams) ([]ListDrawsByDateRow, error) {
	rows, err := q.db.Query(ctx, listDrawsByDate, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDrawsByDateRow
	for rows.Next() {
		var i ListDrawsByDateRow
		if err := rows.Scan(
			&i.ID,
			&i.B1,
			&i.B2,
			&i.B3,
			&i.B4,
			&i.B5,
			&i.B6,
			&i.PatternID,
			&i.DrawDate,
			&i.Amount,
			&i.DrawSections,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertDraw = `-- name: UpsertDraw :exec
INSERT INTO draws (
        id,
        b1,
        b2,
        b3,
        b4,
        b5,
        b6,
        draw_date,
        pattern_id,
        amount,
        balls_freq,
        draw_sections
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12
    ) ON CONFLICT (id) DO
UPDATE
SET b1 = EXCLUDED.b1,
    b2 = EXCLUDED.b2,
    b3 = EXCLUDED.b3,
    b4 = EXCLUDED.b4,
    b5 = EXCLUDED.b5,
    b6 = EXCLUDED.b6,
    draw_date = EXCLUDED.draw_date,
    pattern_id = EXCLUDED.pattern_id,
    amount = EXCLUDED.amount,
    balls_freq = EXCLUDED.balls_freq,
    draw_sections = EXCLUDED.draw_sections
`

type UpsertDrawParams struct {
	ID           int32
	B1           int32
	B2           int32
	B3           int32
	B4           int32
	B5           int32
	B6           int32
	DrawDate     pgtype.Date
	PatternID    int32
	Amount       pgtype.Int4
	BallsFreq    []byte
	DrawSections pgtype.Text
}

// =========================
// DRAWS
// =========================
func (q *Queries) UpsertDraw(ctx context.Context, arg UpsertDrawParams) error {
	_, err := q.db.Exec(ctx, upsertDraw,
		arg.ID,
		arg.B1,
		arg.B2,
		arg.B3,
		arg.B4,
		arg.B5,
		arg.B6,
		arg.DrawDate,
		arg.PatternID,
		arg.Amount,
		arg.BallsFreq,
		arg.DrawSections,
	)
	return err
}

const upsertDrawsBatch = `-- name: UpsertDrawsBatch :exec
INSERT INTO draws (
        id,
        b1,
        b2,
        b3,
        b4,
        b5,
        b6,
        draw_date,
        pattern_id,
        amount,
        balls_freq,
        draw_sections
    )
SELECT UNNEST($1::int []),
    UNNEST($2::int []),
    UNNEST($3::int []),
    UNNEST($4::int []),
    UNNEST($5::int []),
    UNNEST($6::int []),
    UNNEST($7::int []),
    UNNEST($8::date []),
    UNNEST($9::int []),
    UNNEST($10::int []),
    UNNEST($11::jsonb []),
    UNNEST($12::varchar []) ON CONFLICT (id) DO
UPDATE
SET b1 = EXCLUDED.b1,
    b2 = EXCLUDED.b2,
    b3 = EXCLUDED.b3,
    b4 = EXCLUDED.b4,
    b5 = EXCLUDED.b5,
    b6 = EXCLUDED.b6,
    draw_date = EXCLUDED.draw_date,
    pattern_id = EXCLUDED.pattern_id,
    amount = EXCLUDED.amount
`

type UpsertDrawsBatchParams struct {
	Ids          []int32
	B1           []int32
	B2           []int32
	B3           []int32
	B4           []int32
	B5           []int32
	B6           []int32
	DrawDates    []pgtype.Date
	PatternIds   []int32
	Amount       []int32
	BallsFreq    [][]byte
	DrawSections []string
}

func (q *Queries) UpsertDrawsBatch(ctx context.Context, arg UpsertDrawsBatchParams) error {
	_, err := q.db.Exec(ctx, upsertDrawsBatch,
		arg.Ids,
		arg.B1,
		arg.B2,
		arg.B3,
		arg.B4,
		arg.B5,
		arg.B6,
		arg.DrawDates,
		arg.PatternIds,
		arg.Amount,
		arg.BallsFreq,
		arg.DrawSections,
	)
	return err
}
