// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: patterns.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPatterns = `-- name: CountPatterns :one
SELECT COUNT(*)::int4 as total
FROM patterns
`

func (q *Queries) CountPatterns(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, countPatterns)
	var total int32
	err := row.Scan(&total)
	return total, err
}

const fetchAllPatterns = `-- name: FetchAllPatterns :many
SELECT id::int4,
    patterns_amount AS amount,
    pattern
FROM patterns
`

type FetchAllPatternsRow struct {
	ID      int32
	Amount  int32
	Pattern string
}

func (q *Queries) FetchAllPatterns(ctx context.Context) ([]FetchAllPatternsRow, error) {
	rows, err := q.db.Query(ctx, fetchAllPatterns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAllPatternsRow
	for rows.Next() {
		var i FetchAllPatternsRow
		if err := rows.Scan(&i.ID, &i.Amount, &i.Pattern); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPatternAndDrawsByID = `-- name: GetPatternAndDrawsByID :many
SELECT d.id AS draw,
    p.pattern,
    d.draw_date,
    d.b1,
    d.b2,
    d.b3,
    d.b4,
    d.b5,
    d.b6,
    d.amount AS b_sum,
    d.draw_sections,
    p.patterns_amount AS total
FROM draws d
    LEFT JOIN patterns p ON d.pattern_id = p.id
WHERE d.pattern_id = $1
ORDER BY d.id DESC
LIMIT $2 OFFSET $3
`

type GetPatternAndDrawsByIDParams struct {
	PatternID int32
	Limit     int
	Offset    int
}

type GetPatternAndDrawsByIDRow struct {
	Draw         int32
	Pattern      pgtype.Text
	DrawDate     pgtype.Date
	B1           int32
	B2           int32
	B3           int32
	B4           int32
	B5           int32
	B6           int32
	BSum         pgtype.Int4
	DrawSections pgtype.Text
	Total        pgtype.Int4
}

func (q *Queries) GetPatternAndDrawsByID(ctx context.Context, arg GetPatternAndDrawsByIDParams) ([]GetPatternAndDrawsByIDRow, error) {
	rows, err := q.db.Query(ctx, getPatternAndDrawsByID, arg.PatternID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPatternAndDrawsByIDRow
	for rows.Next() {
		var i GetPatternAndDrawsByIDRow
		if err := rows.Scan(
			&i.Draw,
			&i.Pattern,
			&i.DrawDate,
			&i.B1,
			&i.B2,
			&i.B3,
			&i.B4,
			&i.B5,
			&i.B6,
			&i.BSum,
			&i.DrawSections,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPatternByPattern = `-- name: GetPatternByPattern :one
SELECT id::int4,
    patterns_amount AS amount,
    pattern
FROM patterns
WHERE pattern = $1
`

type GetPatternByPatternRow struct {
	ID      int32
	Amount  int32
	Pattern string
}

func (q *Queries) GetPatternByPattern(ctx context.Context, pattern string) (GetPatternByPatternRow, error) {
	row := q.db.QueryRow(ctx, getPatternByPattern, pattern)
	var i GetPatternByPatternRow
	err := row.Scan(&i.ID, &i.Amount, &i.Pattern)
	return i, err
}

const insertNewPattern = `-- name: InsertNewPattern :one
insert into patterns (
        pattern,
        patterns_amount,
        last_used_at,
        last_draw_id
    )
values (
        $1,
        $2,
        $3,
        $4
    )
returning id
`

type InsertNewPatternParams struct {
	Pattern        string
	PatternsAmount int32
	LastUsedAt     pgtype.Timestamp
	LastDrawID     pgtype.Int4
}

// =========================
// PATTERNS
// =========================
func (q *Queries) InsertNewPattern(ctx context.Context, arg InsertNewPatternParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertNewPattern,
		arg.Pattern,
		arg.PatternsAmount,
		arg.LastUsedAt,
		arg.LastDrawID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const listPatternBallsByPattern = `-- name: ListPatternBallsByPattern :many
select ball_id,
    amount
from pattern_balls
where pattern_id = $1::int4
order by ball_id asc
`

type ListPatternBallsByPatternRow struct {
	BallID int32
	Amount int32
}

func (q *Queries) ListPatternBallsByPattern(ctx context.Context, patternID int32) ([]ListPatternBallsByPatternRow, error) {
	rows, err := q.db.Query(ctx, listPatternBallsByPattern, patternID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPatternBallsByPatternRow
	for rows.Next() {
		var i ListPatternBallsByPatternRow
		if err := rows.Scan(&i.BallID, &i.Amount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPatternBallsByPatternPage = `-- name: ListPatternBallsByPatternPage :many
WITH paged_patterns AS (
    SELECT DISTINCT pattern_id::int4
    FROM pattern_balls
    ORDER BY pattern_id
    LIMIT $1 OFFSET $2
)
SELECT pb.pattern_id::int4,
    pb.ball_id::int4,
    p.pattern
FROM pattern_balls pb
    JOIN paged_patterns pp ON pp.pattern_id = pb.pattern_id
    JOIN patterns p on pb.pattern_id = p.id
ORDER BY pb.pattern_id,
    pb.ball_id
`

type ListPatternBallsByPatternPageParams struct {
	Limit  int
	Offset int
}

type ListPatternBallsByPatternPageRow struct {
	PbPatternID int32
	PbBallID    int32
	Pattern     string
}

func (q *Queries) ListPatternBallsByPatternPage(ctx context.Context, arg ListPatternBallsByPatternPageParams) ([]ListPatternBallsByPatternPageRow, error) {
	rows, err := q.db.Query(ctx, listPatternBallsByPatternPage, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPatternBallsByPatternPageRow
	for rows.Next() {
		var i ListPatternBallsByPatternPageRow
		if err := rows.Scan(&i.PbPatternID, &i.PbBallID, &i.Pattern); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPatternsByAmountAsc = `-- name: ListPatternsByAmountAsc :many
SELECT id,
    pattern,
    patterns_amount,
    last_used_at,
    last_draw_id
FROM patterns
ORDER BY patterns_amount ASC
LIMIT $1 OFFSET $2
`

type ListPatternsByAmountAscParams struct {
	Limit  int
	Offset int
}

func (q *Queries) ListPatternsByAmountAsc(ctx context.Context, arg ListPatternsByAmountAscParams) ([]Pattern, error) {
	rows, err := q.db.Query(ctx, listPatternsByAmountAsc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pattern
	for rows.Next() {
		var i Pattern
		if err := rows.Scan(
			&i.ID,
			&i.Pattern,
			&i.PatternsAmount,
			&i.LastUsedAt,
			&i.LastDrawID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPatternsByAmountDesc = `-- name: ListPatternsByAmountDesc :many
SELECT id,
    pattern,
    patterns_amount,
    last_used_at,
    last_draw_id
FROM patterns
ORDER BY patterns_amount DESC
LIMIT $1 OFFSET $2
`

type ListPatternsByAmountDescParams struct {
	Limit  int
	Offset int
}

func (q *Queries) ListPatternsByAmountDesc(ctx context.Context, arg ListPatternsByAmountDescParams) ([]Pattern, error) {
	rows, err := q.db.Query(ctx, listPatternsByAmountDesc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pattern
	for rows.Next() {
		var i Pattern
		if err := rows.Scan(
			&i.ID,
			&i.Pattern,
			&i.PatternsAmount,
			&i.LastUsedAt,
			&i.LastDrawID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPatternsNewest = `-- name: ListPatternsNewest :many
SELECT id,
    pattern,
    patterns_amount,
    last_used_at,
    last_draw_id
FROM patterns
ORDER BY last_used_at DESC NULLS LAST
LIMIT $1 OFFSET $2
`

type ListPatternsNewestParams struct {
	Limit  int
	Offset int
}

func (q *Queries) ListPatternsNewest(ctx context.Context, arg ListPatternsNewestParams) ([]Pattern, error) {
	rows, err := q.db.Query(ctx, listPatternsNewest, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pattern
	for rows.Next() {
		var i Pattern
		if err := rows.Scan(
			&i.ID,
			&i.Pattern,
			&i.PatternsAmount,
			&i.LastUsedAt,
			&i.LastDrawID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPatternsOldest = `-- name: ListPatternsOldest :many
SELECT id,
    pattern,
    patterns_amount,
    last_used_at,
    last_draw_id
FROM patterns
ORDER BY last_used_at ASC NULLS FIRST
LIMIT $1 OFFSET $2
`

type ListPatternsOldestParams struct {
	Limit  int
	Offset int
}

func (q *Queries) ListPatternsOldest(ctx context.Context, arg ListPatternsOldestParams) ([]Pattern, error) {
	rows, err := q.db.Query(ctx, listPatternsOldest, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pattern
	for rows.Next() {
		var i Pattern
		if err := rows.Scan(
			&i.ID,
			&i.Pattern,
			&i.PatternsAmount,
			&i.LastUsedAt,
			&i.LastDrawID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNewPattern = `-- name: UpdateNewPattern :exec
update patterns
set patterns_amount = patterns_amount + 1,
    last_used_at = $1,
    last_draw_id = $2
where id = $3
`

type UpdateNewPatternParams struct {
	LastUsedAt pgtype.Timestamp
	LastDrawID pgtype.Int4
	ID         int32
}

func (q *Queries) UpdateNewPattern(ctx context.Context, arg UpdateNewPatternParams) error {
	_, err := q.db.Exec(ctx, updateNewPattern, arg.LastUsedAt, arg.LastDrawID, arg.ID)
	return err
}

const upsertPatternsIncrementBatch = `-- name: UpsertPatternsIncrementBatch :exec
INSERT INTO patterns (
        id,
        pattern,
        patterns_amount,
        last_used_at,
        last_draw_id
    )
SELECT UNNEST($1::int []),
    UNNEST($2::varchar []),
    UNNEST($3::int []),
    UNNEST($4::timestamp []),
    UNNEST($5::int []) ON CONFLICT (pattern) DO
UPDATE
SET patterns_amount = patterns.patterns_amount + 1,
    last_used_at = GREATEST(patterns.last_used_at, EXCLUDED.last_used_at),
    last_draw_id = CASE
        WHEN EXCLUDED.last_used_at >= patterns.last_used_at THEN EXCLUDED.last_draw_id
        ELSE patterns.last_draw_id
    END
`

type UpsertPatternsIncrementBatchParams struct {
	Column1 []int32
	Column2 []string
	Column3 []int32
	Column4 []pgtype.Timestamp
	Column5 []int32
}

func (q *Queries) UpsertPatternsIncrementBatch(ctx context.Context, arg UpsertPatternsIncrementBatchParams) error {
	_, err := q.db.Exec(ctx, upsertPatternsIncrementBatch,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	return err
}
